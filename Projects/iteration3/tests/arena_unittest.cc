/* STUDENTS:  DO NOT EDIT THIS FILE.  INSTEAD, MODIFY YOUR OWN PROJECT
 * CODE TO FIT THE SPECIFICATION GIVEN BY THE TESTS IN THIS FILE.
 *
 * If you DO modify it, we overwrite it with a fresh version from our repo
 * when grading, so you can't use it to fudge the tests anyway.
 *
 * This file is used by the CS3081W auto-grading system.
 *
 * Please note, the assessment tests for grading, will use the same include
 * files, class names, and function names for accessing students' code that you
 * find in this file.  So students, if you write your code so that it passes
 * these feedback tests, you can be assured that the auto-grader will at least
 * be able to properly link with your code.
 */

/*******************************************************************************
 * Includes
 ******************************************************************************/
#include <gtest/gtest.h>
#include "src/arena.h"
#include "src/arena_params.h"
#include "src/communication.h"
#include "src/entity_type.h"
#include "src/robot.h"
#include "src/params.h"

#ifdef ARENA_TESTS

 /******************************************************
* TEST FEATURE SetUp
*******************************************************/
class ArenaTest : public ::testing::Test {

 protected:
  virtual void SetUp() {
    // Initialize Arena for Collections of TESTS
    csci3081::arena_params aparams;
    arena = new csci3081::Arena(&aparams);
    arena->set_game_status(PLAYING);
    robot = arena->robot();
    entities = arena->get_entities();
    for (auto& entity : entities) {
      if(entity->get_type() == csci3081::kFood)
        home_foods.push_back(entity);
      if(entity->get_type() == csci3081::kLight)
        lights.push_back(entity);
    }
  }

  csci3081::Arena * arena;
  csci3081::Robot * robot;
  std::vector<csci3081::ArenaEntity*> entities;
  std::vector<csci3081::ArenaEntity*> home_foods;
  std::vector<csci3081::ArenaEntity*> lights;

};

/*******************************************************************************
 * Test Cases
 ******************************************************************************/

TEST_F(ArenaTest, Constructor) {
  EXPECT_EQ(arena->get_x_dim(), X_DIM);
  EXPECT_EQ(arena->get_y_dim(), Y_DIM);
  EXPECT_GE((int)entities.size(), 8) << "FAIL: Arena:Constructor - There should be at least 8 entities";
  EXPECT_EQ((int)home_foods.size(), 3) << "FAIL: Arena:Constructor - There should be 3 foods in the arena.";
  EXPECT_GE((int)lights.size(), 4) << "FAIL: Arena:Constructor - There should be at least 4 lights in the arena.";
};

TEST_F(ArenaTest, HomeFoodEqualSize) {
  EXPECT_GT((int)home_foods.size(), 0);
  if(home_foods.size() > 0) {
    double r = home_foods[0]->get_radius();
    for(auto it = home_foods.begin() + 1; it != home_foods.end(); it++)
      EXPECT_EQ(r, (*it)->get_radius()) << "HomeFoods are of different sizes.";
  }
};

TEST_F(ArenaTest, LightNotEqualSize) {
  EXPECT_GT((int)lights.size(), 0);
  if((int)lights.size() > 0) {
    double r = lights[0]->get_radius();
    bool all_equal = true;
    for(auto it = lights.begin() + 1; it != lights.end(); it++) {
      if(r != (*it)->get_radius())
        all_equal = false;
    }
      EXPECT_FALSE(all_equal) << "Lights are not of different sizes.";
  }
};

TEST_F(ArenaTest, Win) {
  for(auto& hb : home_foods) {
    hb->set_position(200, 200);
    robot->set_position(200, 200);
    arena->AdvanceTime(1);
    hb->set_position(0, 0);
  }
  arena->AdvanceTime(1);
  EXPECT_EQ(arena->get_game_status(), WON);
};

TEST_F(ArenaTest, LossOnHittingWall) {
  int lives = 1;
  robot->set_lives(lives);
  for(int i=0;i<lives+1;i++) {
    robot->set_position(robot->get_radius() + arena->get_x_dim() + 5, 0);
    arena->AdvanceTime(1);
  }
  EXPECT_EQ(arena->get_game_status(), LOST);
};

#endif /* ARENA_TESTS */
